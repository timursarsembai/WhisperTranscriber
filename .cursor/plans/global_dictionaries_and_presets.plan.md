# План: глобальные словари, пресеты, prompt и постобработка

## Цели

- **Глобальный пул словарей**: все словари хранятся в одной папке приложения (общей для всех проектов).
- В проекте сохраняются только **включённые словари** (список ID); при сохранении проекта этот список записывается в `.wiproject`.
- **Типы словарей**: исправления (original → corrected) и подсказки (только термины); один формат файла с полем `type`.
- **Пресеты**: именованные наборы включённых словарей (глобально); применение пресета подставляет список включённых в текущий проект.
- **Разделение**: подсказки (terms) — только в initial_prompt; исправления (correction) — в prompt и опционально постобработка по сегментам после транскрипции.
- **Исключено из плана**: словари только для конкретных файлов, словарь перевода.

---

## 1. Где хранить глобальные словари

- **Папка**: одна директория на всё приложение, не привязанная к проекту.
- **Вариант**: та же база, что и для конфига — в `i18n.py` используется `_config_path()` (рядом с exe или со скриптом). Добавить функцию вида `get_dictionaries_dir()` → `os.path.join(base, "dictionaries")`. При первом использовании создавать папку.
- **Файлы в папке**: один файл = один словарь. Расширение `.json` или `.widict`. Идентификатор словаря в рамках приложения — имя файла (например `technical_terms.json`), чтобы в сессии хранить список строк без путей.

---

## 2. Формат файла словаря (единый, с полем type)

Один формат для всех типов, поле `type` задаёт смысл записей:

```json
{
  "version": 1,
  "type": "correction",
  "name": "Общие исправления",
  "entries": [
    { "original": "как распознано", "corrected": "как надо" }
  ]
}
```

- **type**: `"correction"` | `"terms"`.
- **correction**: entries — массив `{ "original", "corrected" }` (как сейчас в GlossaryService.py).
- **terms**: entries — массив `{ "term" }` (одно поле) или для совместимости пар можно допустить `{ "original", "corrected" }` с одинаковым значением.
- **name**: отображаемое имя в UI.
- **version**: схема для обратной совместимости.
- **Обратная совместимость**: при загрузке файла без поля `type` (старый глоссарий) считать тип `correction` и парсить entries в текущем виде.

---

## 3. Модуль словарей (DictionaryService)

Вынести/расширить логику из GlossaryService.py в новый или переименованный сервис (например DictionaryService), который:

- **Путь к папке**: `get_dictionaries_dir()` — база приложения + `"dictionaries"`.
- **Список словарей**: `list_dictionaries()` → список `{ "id": "filename.json", "path": abs_path, "name", "type" }` по файлам в папке (чтение только метаданных: version, type, name из каждого файла).
- **Загрузка**: `load(path)` / `load_by_id(id)` → объект с полями type, name, entries (нормализованные: для terms — список строк или пар term/term).
- **Сохранение**: `save(path, data)` в описанном формате.
- **Формирование prompt**:
  - `build_initial_prompt_text(dictionaries: List[DictionaryData])`:
  - из всех записей типа **terms** — одна секция вида «Use these terms: term1, term2, …»;
  - из всех записей типа **correction** — секция «Use as written: original -> corrected» (как сейчас get_initial_prompt_text).
  - Объединить секции в один текст для Whisper.
- **Постобработка**: `apply_corrections_to_segments(segments: List[dict], correction_entries: List[{original, corrected}])` — для каждого сегмента заменить в `segment["text"]` вхождения original на corrected (по всем переданным записям исправлений). Вызывать после транскрипции, если включена опция «применять исправления к тексту».

Старый GlossaryService можно оставить для обратной совместимости загрузки старых файлов или перенести его функции в DictionaryService с автоопределением формата по наличию `type` в JSON.

---

## 4. Сессия проекта: что хранить

В SessionService.py, SessionData:

- Добавить поле **enabled_dictionary_ids**: `Optional[List[str]] = None` — список ID словарей (имена файлов в глобальной папке), включённых для этого проекта.
- **Сохранение**: в to_dict и в save_session записывать `enabled_dictionary_ids` в JSON .wiproject.
- **Загрузка**: в from_dict и load_session читать `enabled_dictionary_ids`; если нет — оставить None или [].
- **Обратная совместимость**: оставить glossary_path. При загрузке сессии:
  - если есть **enabled_dictionary_ids** (и не пустой) — использовать только их (загружать словари из глобальной папки);
  - иначе если есть **glossary_path** — загрузить один файл по этому пути и считать его «одним включённым словарём» для текущей сессии (без добавления в глобальную папку). Так старые проекты продолжают работать. При следующем сохранении можно по-прежнему сохранять glossary_path (если он был) или предложить миграцию в UI позже.

В main.py при сохранении сессии передавать в SessionService.build_session текущий список включённых ID вместо одного glossary_path; при открытии — восстанавливать включённые словари из enabled_dictionary_ids (или из glossary_path при legacy).

---

## 5. Пресеты

- **Хранение**: глобально, не в проекте. Удобный вариант — в том же конфиге приложения, что и остальные настройки: в i18n.py load_config/save_config уже работают с wi_config.json. Добавить ключ, например **dictionary_presets**: массив `{ "name": "Подкасты", "enabled_ids": ["dict1.json", "dict2.json"] }`.
- **Поведение**: «Применить пресет» — взять enabled_ids выбранного пресета и установить их как текущий список включённых словарей проекта (в состоянии приложения и при следующем сохранении проекта — в сессию). «Сохранить текущий набор как пресет» — запросить имя, добавить в dictionary_presets объект с текущим enabled_dictionary_ids и сохранить конфиг.

---

## 6. Состояние приложения и использование при транскрипции

В main.py:

- Убрать (или оставить только для legacy): один current_glossary_path и один current_glossary.
- **Ввести**: список включённых ID для текущего проекта — **enabled_dictionary_ids**: `List[str]` (и при открытии проекта заполнять из сессии; при отсутствии проекта — пустой список). По необходимости — кэш загруженных словарей по ID, чтобы не читать файлы при каждом запросе.
- **Формирование prompt**: при транскрипции файла и при использовании микрофона с опцией «использовать словари» — по enabled_dictionary_ids загрузить словари из глобальной папки (или из кэша), передать их в DictionaryService.build_initial_prompt_text(...) и результат отдать в initial_prompt в TranscriptionService (сигнатура transcribe не меняется — по-прежнему строка).
- **Постобработка**: после получения full_results из transcribe, если включена настройка «применять исправления к тексту после транскрипции», собрать все записи типа correction из включённых словарей и вызвать DictionaryService.apply_corrections_to_segments(self.full_results, correction_entries), затем обновить UI (сегменты уже с подставленным текстом). Места вызова: файловая транскрипция (~2555–2576) и при необходимости потоковая/микрофон (если там тоже возвращается итоговый текст по сегментам).
- Чекбокс «использовать глоссарий» для микрофона переименовать в духе «использовать словари» и привязывать к наличию хотя бы одного включённого словаря.

---

## 7. UI: вкладка «Словари» (бывший «Глоссарий»)

Переименовать вкладку и перестроить панель в main.py (_build_glossary_panel → например _build_dictionaries_panel):

### Блок «Глобальные словари»

- Список всех словарей из get_dictionaries_dir(): имя (name), тип (correction/terms), ID (имя файла). Кнопки: «Добавить словарь» (создать новый файл в папке, запросить имя и тип), «Открыть папку», «Обновить».
- При выборе словаря в списке — ниже показывать его записи и редактирование: для типа correction — пары «Было / Стало» и кнопки Добавить/Изменить/Удалить; для типа terms — список терминов и добавление/удаление. Кнопка «Сохранить» — запись в файл словаря в глобальной папке.

### Блок «Включено в этом проекте»

- Если проект открыт: список всех глобальных словарей с чекбоксами (или мультиселект); отмечены те, чьи ID входят в enabled_dictionary_ids. Изменение чекбоксов сразу меняет enabled_dictionary_ids в состоянии приложения; при сохранении проекта они попадут в сессию.
- Если проект не открыт — подпись «Откройте проект, чтобы включать словари» и неактивные чекбоксы или скрытие блока.

### Блок «Пресеты»

- Выпадающий список (или список по имени) пресетов из конфига. Кнопка «Применить» — подставить enabled_ids пресета в enabled_dictionary_ids и обновить чекбоксы в блоке 2. Кнопка «Сохранить текущий набор как пресет» — ввод имени, добавление в dictionary_presets и сохранение конфига.

### Опции

- Чекбокс «Применять исправления к тексту после транскрипции» (значение хранить в конфиге приложения, например apply_corrections_post: true/false), использовать при постобработке после transcribe.

**Локализация**: добавить ключи для «Словари», «Глобальные словари», «Включено в проекте», «Пресеты», «Применить», «Сохранить как пресет», «Применять исправления после транскрипции», «Добавить словарь», «Тип: исправления / подсказки» и т.д. в locales.

---

## 8. Порядок внедрения (логические шаги)

```
flowchart LR
  subgraph data [Данные и сервис]
    A[Формат файла type name entries]
    B[get_dictionaries_dir list load save]
    C[build_initial_prompt_text]
    D[apply_corrections_to_segments]
  end
  subgraph session [Сессия]
    E[enabled_dictionary_ids в SessionData]
    F[save/load в wiproject]
    G[обратная совместимость glossary_path]
  end
  subgraph app [Приложение]
    H[Состояние enabled_dictionary_ids в main]
    I[Prompt при транскрипции и мик]
    J[Постобработка по опции]
  end
  subgraph ui [UI и пресеты]
    K[Панель словарей и пресеты в конфиге]
    L[Чекбоксы включения и опция постобработки]
  end
  A --> B
  B --> C
  B --> D
  C --> I
  D --> J
  E --> F
  F --> H
  G --> H
  H --> I
  H --> K
  K --> L
```

1. **Формат и DictionaryService**: формат файла, путь к папке, list/load/save, build_initial_prompt_text, apply_corrections_to_segments; обратная совместимость загрузки старого глоссария без type.
2. **Сессия**: поле enabled_dictionary_ids, запись/чтение в .wiproject, логика legacy при наличии только glossary_path.
3. **main.py**: состояние enabled_dictionary_ids, подстановка при сохранении/загрузке проекта, формирование prompt из включённых словарей, постобработка по флагу.
4. **UI**: новая панель словарей (глобальный список, выбор и редактирование, включение в проекте, пресеты, чекбокс постобработки), локализация.
5. **Пресеты**: сохранение/загрузка из конфига, применение и «сохранить как пресет».

---

## 9. Важные файлы

| Что | Где |
|-----|-----|
| Путь к папке словарей | Новый/общий модуль или i18n: функция рядом с _config_path |
| Формат и загрузка/сохранение | GlossaryService.py → расширить в DictionaryService или новый файл DictionaryService.py |
| Сессия | SessionService.py: SessionData.enabled_dictionary_ids, to_dict/from_dict, build_session |
| Транскрипция и prompt | main.py: вызовы transcribe, место после transcribe для apply_corrections_to_segments |
| UI панели и пресеты | main.py: _build_glossary_panel → _build_dictionaries_panel |
| Конфиг пресетов и опции | i18n.py load_config/save_config или тот же wi_config.json |
| Локализация | locales/en.json, ru, kk, es — новые ключи dictionaries.* |

**Миграция**: при первом открытии старого проекта с glossary_path ничего не переносим в глобальную папку автоматически; просто загружаем файл по пути и используем его как раньше. При желании позже можно добавить кнопку «Перенести в глобальные словари» в UI.
